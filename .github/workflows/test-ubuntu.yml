name: SWHID Testing Harness (Ubuntu)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for commit info
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: 'pip'  # Automatically cache pip packages
          # Note: setup-python@v5 handles pip caching automatically, no need for explicit cache step
      
      - name: Install system dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y libgit2-dev pkg-config libssl-dev
        continue-on-error: true
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .[dev] psutil
      
      - name: Install Software Heritage Python tools
        shell: bash
        run: |
          pip install swh.model swh.core || echo "Warning: swh Python tools not available, some implementations may be skipped"
        continue-on-error: true
      
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: false
        continue-on-error: true
      
      - name: Cache swhid gem
        id: cache-swhid-gem
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.gem/ruby
            ~/.local/share/gem
            /opt/hostedtoolcache/Ruby/*/x64/lib/ruby/gems
          # Note: Cache key doesn't include version - we validate after restore
          # Use hardcoded /opt/hostedtoolcache for Ubuntu (this workflow only runs on Ubuntu)
          key: swhid-gem-${{ runner.os }}-ruby-3.2
          restore-keys: |
            swhid-gem-${{ runner.os }}-ruby-3.2
            swhid-gem-${{ runner.os }}-ruby-3.2-
            swhid-gem-${{ runner.os }}-
      
      - name: Determine CPU cores
        id: cpu-cores
        shell: bash
        run: |
          if command -v nproc >/dev/null 2>&1; then
            CORES=$(nproc)
          elif command -v sysctl >/dev/null 2>&1; then
            CORES=$(sysctl -n hw.ncpu)
          elif command -v getconf >/dev/null 2>&1; then
            CORES=$(getconf _NPROCESSORS_ONLN)
          else
            CORES=4
          fi
          echo "cores=${CORES}" >> $GITHUB_OUTPUT
          echo "Using parallel compilation with ${CORES} cores"
      
      - name: Install swhid gem
        shell: bash
        run: |
          # Get cores from previous step (with fallback)
          CORES="${{ steps.cpu-cores.outputs.cores }}"
          if [ -z "${CORES}" ] || [ "${CORES}" = "" ]; then
            # Fallback if output not available
            if command -v nproc >/dev/null 2>&1; then
              CORES=$(nproc)
            elif command -v sysctl >/dev/null 2>&1; then
              CORES=$(sysctl -n hw.ncpu)
            else
              CORES=4
            fi
          fi
          
          # Unset any existing MAKE variable that might have wrong value
          unset MAKE || true
          
          # Set MAKE with evaluated cores value
          export MAKE="make -j${CORES}"
          echo "MAKE variable set to: ${MAKE}"
          echo "Verifying MAKE variable:"
          echo "${MAKE}" | head -1
          
          # Check cache restore status first
          echo "=== Gem cache status ==="
          echo "cache-hit=${{ steps.cache-swhid-gem.outputs.cache-hit }}"
          
          # Verify cache was actually restored by checking if gem files exist
          echo "Checking for cached gem files..."
          CACHED_GEM_FOUND=false
          if [ -d ~/.local/share/gem/ruby/3.2.0/gems/swhid-* ] 2>/dev/null || \
             [ -d ~/.gem/ruby/3.2.0/gems/swhid-* ] 2>/dev/null || \
             [ -d /opt/hostedtoolcache/Ruby/3.2.9/x64/lib/ruby/gems/3.2.0/gems/swhid-* ] 2>/dev/null; then
            CACHED_GEM_FOUND=true
            echo "‚úÖ Found cached gem files in cache directories"
            find ~/.local/share/gem ~/.gem /opt/hostedtoolcache/Ruby -type d -name "swhid-*" 2>/dev/null | head -3 || true
          else
            echo "‚ö†Ô∏è No cached gem files found in cache directories"
          fi
          
          # Check if gem is already installed and validate version
          INSTALLED_VERSION=""
          GEM_AVAILABLE=false
          
          # Note: cache-hit is only true for exact key matches
          # When restore-keys match, cache is restored but cache-hit=false
          # So we check if gem is actually available, not just cache-hit status
          if gem list -i swhid >/dev/null 2>&1; then
            INSTALLED_VERSION=$(gem list swhid | grep -E "^\s*swhid\s" | sed -E 's/^\s*swhid\s+\(([^)]+)\).*/\1/' | head -1 || echo "")
            echo "swhid gem found in cache: version ${INSTALLED_VERSION}"
            
            # Verify gem is actually usable (not just listed)
            if ruby -r swhid -e "true" 2>/dev/null; then
              GEM_AVAILABLE=true
              echo "Verified: Cached gem is usable"
            else
              echo "Warning: Cached gem is listed but not usable, will reinstall"
              GEM_AVAILABLE=false
            fi
          else
            # Cache might have been restored but gem not found yet
            # This can happen if cache paths don't match Ruby's gem paths exactly
            if [ "$CACHED_GEM_FOUND" = "true" ]; then
              echo "‚ö†Ô∏è Cached gem files found but gem not recognized by 'gem list'"
              echo "This may indicate Ruby needs to reload gem paths - will reinstall to ensure gem is available"
            elif [ "${{ steps.cache-swhid-gem.outputs.cache-hit }}" = "true" ]; then
              echo "‚ö†Ô∏è Cache was restored (cache-hit=true) but gem files not found"
              echo "Cache may be empty or corrupted - will reinstall"
            else
              echo "Gem not found via 'gem list'"
            fi
          fi
          
          # Get latest available version
          GEM_SEARCH_OUTPUT=$(gem search -r -e swhid 2>/dev/null | grep -E "^swhid\s" | head -1 || echo "")
          if [ -n "$GEM_SEARCH_OUTPUT" ]; then
            LATEST_VERSION=$(echo "$GEM_SEARCH_OUTPUT" | sed -E 's/^swhid\s+\(([^,)]+).*\)$/\1/' | xargs)
            echo "Latest available swhid gem version: ${LATEST_VERSION}"
            
            # Check if we need to reinstall
            if [ -n "$INSTALLED_VERSION" ] && [ "$INSTALLED_VERSION" = "$LATEST_VERSION" ] && [ "$GEM_AVAILABLE" = "true" ]; then
              echo "Cached gem version (${INSTALLED_VERSION}) matches latest and is usable, using cache"
              gem list swhid
            else
              if [ -n "$INSTALLED_VERSION" ]; then
                echo "Cached gem version (${INSTALLED_VERSION}) differs from latest (${LATEST_VERSION}), reinstalling..."
              else
                echo "Installing swhid gem (this may take a while for native extensions)..."
              fi
              # Uninstall old version if exists, then install latest
              gem uninstall swhid -x 2>/dev/null || true
              env MAKE="${MAKE}" gem install swhid --no-document || echo "Warning: swhid gem not available, Ruby implementation will be skipped"
            fi
          else
            # Fallback: if we can't check version, use cached gem if available and usable
            if [ -n "$INSTALLED_VERSION" ] && [ "$GEM_AVAILABLE" = "true" ]; then
              echo "Cannot check latest version, using cached gem (${INSTALLED_VERSION})"
              gem list swhid
            else
              echo "Installing swhid gem (this may take a while for native extensions)..."
              env MAKE="${MAKE}" gem install swhid --no-document || echo "Warning: swhid gem not available, Ruby implementation will be skipped"
            fi
          fi
          
          # Ensure gem bin directory is in PATH for harness to find swhid command
          # ruby/setup-ruby should do this, but let's be explicit
          set +e  # Temporarily disable exit on error for detection logic
          
          # Method 1: Use gem env to get executable directory
          GEM_BIN_DIR=$(gem env 2>/dev/null | grep -E "EXECUTABLE DIRECTORY" | sed 's/.*: *//' 2>/dev/null | head -1 || echo "")
          
          # Method 2: Try Gem.user_dir
          if [ -z "$GEM_BIN_DIR" ] || [ ! -d "$GEM_BIN_DIR" ]; then
            GEM_USER_DIR=$(ruby -e "puts Gem.user_dir" 2>/dev/null || echo "")
            if [ -n "$GEM_USER_DIR" ] && [ "$GEM_USER_DIR" != "" ]; then
              GEM_BIN_DIR="$GEM_USER_DIR/bin"
            fi
          fi
          
          # Method 3: Search for swhid executable and use its directory
          if [ -z "$GEM_BIN_DIR" ] || [ ! -d "$GEM_BIN_DIR" ] || [ ! -f "$GEM_BIN_DIR/swhid" ]; then
            # Search in common gem installation locations
            SWHID_PATH=$(find ~/.local/share/gem ~/.gem /opt/hostedtoolcache/Ruby -name swhid -type f 2>/dev/null | head -1 || echo "")
            if [ -n "$SWHID_PATH" ] && [ "$SWHID_PATH" != "" ]; then
              GEM_BIN_DIR=$(dirname "$SWHID_PATH")
              echo "Found swhid at: $SWHID_PATH"
            fi
          fi
          
          # Method 4: Try common locations
          if [ -z "$GEM_BIN_DIR" ] || [ ! -d "$GEM_BIN_DIR" ]; then
            for dir in ~/.local/share/gem/ruby/*/bin ~/.gem/ruby/*/bin /opt/hostedtoolcache/Ruby/*/x64/lib/ruby/gems/*/bin; do
              if [ -d "$dir" ] && [ -f "$dir/swhid" ] 2>/dev/null; then
                GEM_BIN_DIR="$dir"
                echo "Found swhid in: $dir"
                break
              fi
            done
          fi
          
          set -e  # Re-enable exit on error
          
          # Add to PATH if found
          if [ -n "$GEM_BIN_DIR" ] && [ "$GEM_BIN_DIR" != "" ] && [ -d "$GEM_BIN_DIR" ]; then
            # Add to GITHUB_PATH (affects subsequent steps)
            echo "$GEM_BIN_DIR" >> $GITHUB_PATH
            # Also add to current PATH for this step
            export PATH="$GEM_BIN_DIR:$PATH"
            echo "‚úÖ Added gem bin directory to PATH: $GEM_BIN_DIR"
          else
            echo "‚ö†Ô∏è Warning: Could not determine gem bin directory"
            echo "Gem environment:"
            gem env 2>/dev/null | grep -E "(EXECUTABLE|INSTALLATION)" || true
          fi
          
          # Verify swhid command is accessible
          if command -v swhid >/dev/null 2>&1; then
            echo "‚úÖ swhid command found in PATH: $(which swhid)"
          else
            echo "‚ö†Ô∏è Warning: swhid command not found in PATH, but gem is installed"
            echo "Gem bin directory: $GEM_BIN_DIR"
            echo "Searching for swhid command..."
            find ~/.local/share/gem ~/.gem /opt/hostedtoolcache/Ruby -name swhid -type f 2>/dev/null | head -5 || echo "Not found in common locations"
            echo "Current PATH: $PATH"
          fi
        continue-on-error: true
      
      - name: Configure Git for SWHID testing
        shell: bash
        run: |
          # Configure Git to preserve line endings and file permissions for SWHID testing
          git config --global core.autocrlf false
          git config --global core.filemode true
          git config --global core.precomposeunicode false
          git config --global core.quotepath false
          echo "Git configured for SWHID testing"
      
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
        continue-on-error: true
      
      - name: Cache Cargo registry and git cache
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          # Note: Cargo.lock is in swhid-rs repo (cloned later), so we use a simple key
          # The cache is for downloaded crates, which are versioned by Cargo itself
          # Cargo will re-download if versions don't match, so this cache is safe
          key: cargo-${{ runner.os }}-registry
          restore-keys: |
            cargo-${{ runner.os }}-
      
      - name: Cache swhid-rs build artifacts
        id: cache-swhid-rs
        uses: actions/cache/restore@v4
        continue-on-error: true
        with:
          # Use /tmp/swhid-rs/target - works on all platforms with bash shell
          # Try workflow-specific cache first, then fall back to generic cache
          # This allows both workflows to share caches while avoiding save conflicts
          # Note: Cache keys include commit hash from swhid-rs repo (format: key-<commit-hash>)
          # Since we don't know the commit hash yet (repo not cloned), we use restore-keys
          # restore-keys use prefix matching and return the most recently created cache
          # The commit marker file inside the cache will validate if it matches current commit
          path: /tmp/swhid-rs/target
          # Use a key that won't match - restore-keys will find the most recent cache with matching prefix
          # According to GitHub docs: if multiple caches match a restore-key, the most recently created is used
          key: swhid-rs-Linux-stable-ubuntu-workflow-${{ github.run_id }}-no-match
          restore-keys: |
            swhid-rs-Linux-stable-ubuntu-workflow-
            swhid-rs-Linux-stable-multi-platform-workflow-
            swhid-rs-Linux-stable-
            swhid-rs-Linux-
      
      - name: Check cache restore status
        shell: bash
        run: |
          echo "=== Cache restore status ==="
          echo "cache-hit=${{ steps.cache-swhid-rs.outputs.cache-hit }}"
          echo ""
          
          # Note: cache-hit is only true for exact key matches
          # When restore-keys match, cache is restored but cache-hit=false
          # So we check if the binary actually exists to determine if cache was restored
          if [ -d /tmp/swhid-rs/target/release ] && [ -f /tmp/swhid-rs/target/release/swhid ]; then
            echo "‚úÖ Cache was restored (binary found)"
            CACHED_COMMIT_FILE="/tmp/swhid-rs/target/.swhid-rs-commit"
            if [ -f "$CACHED_COMMIT_FILE" ]; then
              CACHED_COMMIT=$(cat "$CACHED_COMMIT_FILE" 2>/dev/null || echo "unknown")
              echo "‚úÖ Found cached binary for commit ${CACHED_COMMIT:0:7}"
              echo "Cached commit: $CACHED_COMMIT"
            else
              echo "‚ö†Ô∏è Found cached binary but no commit marker (will need validation)"
            fi
          elif [ "${{ steps.cache-swhid-rs.outputs.cache-hit }}" = "true" ]; then
            echo "‚úÖ Cache was restored (cache-hit=true, but binary not found - may need rebuild)"
          else
            echo "‚ùå Cache was not restored (cache-hit=false and binary not found)"
          fi
        continue-on-error: true
      
      - name: Fix binary permissions after cache restore
        shell: bash
        run: |
          echo "=== Ensuring binary is executable ==="
          # When cache is restored, file permissions might not be preserved correctly
          # Ensure the swhid binary is executable
          if [ -f /tmp/swhid-rs/target/release/swhid ]; then
            echo "Setting execute permissions on cached binary..."
            chmod +x /tmp/swhid-rs/target/release/swhid
            echo "‚úÖ Binary permissions fixed"
            ls -l /tmp/swhid-rs/target/release/swhid || true
          else
            echo "No binary found yet (will be built or permissions set during build)"
          fi
        continue-on-error: true
      
      - name: Setup SSH for private repository access (optional)
        shell: bash
        run: |
          mkdir -p ~/.ssh
          if [ -n "${{ secrets.SWHID_RS_SSH_KEY }}" ]; then
            echo "${{ secrets.SWHID_RS_SSH_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null
            echo "SSH key configured for repository access"
          else
            echo "No SSH key provided - using public HTTPS access"
          fi
        continue-on-error: true
      
      - name: Clone and build swhid-rs
        id: swhid-rs-setup
        shell: bash
        env:
          SWHID_RS_REPO: ${{ secrets.SWHID_RS_REPO || 'https://github.com/swhid/swhid-rs.git' }}
          SWHID_RS_TOKEN: ${{ secrets.SWHID_RS_TOKEN }}
        run: |
          set +e
          # Preserve cached target/ directory if it exists
          if [ -d /tmp/swhid-rs/target ]; then
            echo "Preserving cached build artifacts..."
            mkdir -p /tmp/swhid-rs-cache-backup
            mv /tmp/swhid-rs/target /tmp/swhid-rs-cache-backup/ || true
          fi
          
          # Clean up any existing /tmp/swhid-rs directory
          if [ -d /tmp/swhid-rs ]; then
            echo "Cleaning up existing /tmp/swhid-rs directory..."
            rm -rf /tmp/swhid-rs
          fi
          
          # Try to clone the swhid-rs repository
          if [ -n "$SWHID_RS_REPO" ]; then
            echo "Attempting to clone swhid-rs from $SWHID_RS_REPO"
            # Use HTTPS with token if available (for private repos, or public access if no token)
            if [[ "$SWHID_RS_REPO" == https://* ]]; then
              # Force HTTPS by disabling SSH and avoiding system Git configs
              echo "=== Debug: Git configuration before clone ==="
              echo "Git version: $(git --version)"
              echo "GIT_SSH_COMMAND: ${GIT_SSH_COMMAND:-<unset>}"
              echo "GIT_CONFIG_NOSYSTEM: ${GIT_CONFIG_NOSYSTEM:-<unset>}"
              echo "SSH key exists: $([ -f ~/.ssh/id_rsa ] && echo 'yes' || echo 'no')"
              git config --global --list 2>/dev/null | grep -E "(url|ssh)" || echo "No global URL/SSH configs"
              git config --system --list 2>/dev/null | grep -E "(url|ssh)" || echo "No system URL/SSH configs"
              echo "Testing URL parsing..."
              echo "Original URL: $SWHID_RS_REPO"
              echo "=== End debug ==="
              
              # Completely disable SSH for this operation
              unset GIT_SSH_COMMAND
              unset GIT_SSH
              export GIT_CONFIG_NOSYSTEM=1
              export GIT_SSH_VARIANT=simple
              export GIT_TERMINAL_PROMPT=0
              
              if [ -n "$SWHID_RS_TOKEN" ]; then
                # Use dedicated token for repository access (if needed for private repos)
                # Construct URL properly: extract domain and path, then rebuild with token
                REPO_URL="https://${SWHID_RS_TOKEN}@${SWHID_RS_REPO#https://}"
                echo "Using token for repository access"
                echo "Repository URL (masked): https://***@${SWHID_RS_REPO#https://}"
                echo "Attempting clone with explicit HTTPS..."
                # Unset GIT_SSH_COMMAND (don't set to empty string) and force HTTPS
                (unset GIT_SSH_COMMAND; unset GIT_SSH; GIT_CONFIG_NOSYSTEM=1 git clone "$REPO_URL" /tmp/swhid-rs 2>&1) | tee /tmp/swhid-rs-clone.log
                CLONE_EXIT_CODE=${PIPESTATUS[0]}
              elif [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
                # Fallback to GITHUB_TOKEN if available (for private repos)
                GITHUB_TOKEN_VALUE="${{ secrets.GITHUB_TOKEN }}"
                REPO_URL="https://${GITHUB_TOKEN_VALUE}@${SWHID_RS_REPO#https://}"
                echo "Using GITHUB_TOKEN for repository access"
                echo "Repository URL (masked): https://***@${SWHID_RS_REPO#https://}"
                echo "Attempting clone with explicit HTTPS..."
                (unset GIT_SSH_COMMAND; unset GIT_SSH; GIT_CONFIG_NOSYSTEM=1 git clone "$REPO_URL" /tmp/swhid-rs 2>&1) | tee /tmp/swhid-rs-clone.log
                CLONE_EXIT_CODE=${PIPESTATUS[0]}
              else
                # Use public access (works for public repositories)
                echo "No token available, using public HTTPS access"
                echo "Attempting clone with explicit HTTPS..."
                (unset GIT_SSH_COMMAND; unset GIT_SSH; GIT_CONFIG_NOSYSTEM=1 git clone "$SWHID_RS_REPO" /tmp/swhid-rs 2>&1) | tee /tmp/swhid-rs-clone.log
                CLONE_EXIT_CODE=${PIPESTATUS[0]}
              fi
            else
              # SSH URL - use SSH key if configured
              git clone "$SWHID_RS_REPO" /tmp/swhid-rs 2>&1 | tee /tmp/swhid-rs-clone.log
              CLONE_EXIT_CODE=${PIPESTATUS[0]}
            fi
            if [ $CLONE_EXIT_CODE -eq 0 ] && [ -d /tmp/swhid-rs ]; then
              cd /tmp/swhid-rs
              
              # Get the current commit hash of swhid-rs to check if we need to rebuild
              SWHID_RS_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
              echo "swhid-rs commit: ${SWHID_RS_COMMIT:0:7}"
              
              # Restore cached target/ directory if it was preserved
              if [ -d /tmp/swhid-rs-cache-backup/target ]; then
                echo "Restoring cached build artifacts..."
                mv /tmp/swhid-rs-cache-backup/target . || true
                rm -rf /tmp/swhid-rs-cache-backup || true
              fi
              
              # Check if we have cached build artifacts and if they match current source
              # We check for the binary AND verify it was built from the same commit
              CACHED_COMMIT_FILE="target/.swhid-rs-commit"
              NEED_REBUILD=true
              REBUILT=false
              
              if [ -d target/release ] && [ -f target/release/swhid ]; then
                if [ -f "$CACHED_COMMIT_FILE" ]; then
                  CACHED_COMMIT=$(cat "$CACHED_COMMIT_FILE" 2>/dev/null || echo "")
                  if [ "$CACHED_COMMIT" = "$SWHID_RS_COMMIT" ]; then
                    echo "‚úÖ Using cached swhid-rs binary (commit ${SWHID_RS_COMMIT:0:7})"
                    echo "Cache validation: Commit hash matches, no rebuild needed"
                    BUILD_EXIT_CODE=0
                    NEED_REBUILD=false
                  else
                    echo "üîÑ Changes detected: Cached commit ${CACHED_COMMIT:0:7} != current commit ${SWHID_RS_COMMIT:0:7}"
                    echo "Cached commit: ${CACHED_COMMIT:0:7}"
                    echo "Current commit: ${SWHID_RS_COMMIT:0:7}"
                    echo "Rebuilding swhid-rs to match current commit..."
                  fi
                else
                  echo "‚ö†Ô∏è Cached binary exists but no commit marker found, rebuilding to be safe..."
                fi
              else
                echo "‚ùå No cached binary found, building swhid-rs..."
              fi
              
              if [ "$NEED_REBUILD" = "true" ]; then
                cargo build --release --features git 2>&1 | tee /tmp/swhid-rs-build.log
                BUILD_EXIT_CODE=${PIPESTATUS[0]}
                if [ $BUILD_EXIT_CODE -eq 0 ]; then
                  REBUILT=true
                  # Ensure binary is executable (Cargo should set this, but be explicit)
                  if [ -f target/release/swhid ]; then
                    chmod +x target/release/swhid
                    echo "‚úÖ Binary built and permissions set"
                  fi
                  # Save the commit hash for future cache validation
                  # Ensure target directory exists and write commit marker
                  mkdir -p target
                  echo "$SWHID_RS_COMMIT" > "$CACHED_COMMIT_FILE"
                  echo "Build completed successfully, saved commit marker to $CACHED_COMMIT_FILE"
                  # Verify the file was written
                  if [ -f "$CACHED_COMMIT_FILE" ]; then
                    echo "Commit marker verified: $(cat "$CACHED_COMMIT_FILE")"
                  else
                    echo "WARNING: Commit marker file was not created!"
                  fi
                fi
              fi
              
              # Set output to indicate if we rebuilt (needed for cache save step)
              echo "swhid_rs_rebuilt=${REBUILT}" >> $GITHUB_OUTPUT
              if [ $BUILD_EXIT_CODE -eq 0 ]; then
                echo "swhid-rs built successfully"
                echo "SWHID_RS_PATH=/tmp/swhid-rs" >> $GITHUB_ENV
                echo "swhid_rs_available=true" >> $GITHUB_ENV
                echo "‚úÖ swhid-rs is available" >> $GITHUB_STEP_SUMMARY
              else
                echo "swhid-rs build failed (exit code: $BUILD_EXIT_CODE)"
                echo "Last 20 lines of build log:"
                tail -20 /tmp/swhid-rs-build.log || true
                echo "swhid_rs_available=false" >> $GITHUB_ENV
                echo "‚ö†Ô∏è swhid-rs build failed" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "swhid-rs repository clone failed (exit code: $CLONE_EXIT_CODE)"
              if [ -f /tmp/swhid-rs-clone.log ]; then
                echo "Clone log:"
                cat /tmp/swhid-rs-clone.log
              fi
              if [ ! -d /tmp/swhid-rs ]; then
                echo "Directory /tmp/swhid-rs does not exist"
              fi
              echo "swhid_rs_available=false" >> $GITHUB_ENV
              echo "‚ÑπÔ∏è swhid-rs repository not accessible - Rust implementation will be skipped" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "SWHID_RS_REPO not configured"
            echo "swhid_rs_available=false" >> $GITHUB_ENV
            echo "‚ÑπÔ∏è SWHID_RS_REPO not configured - Rust implementation will be skipped" >> $GITHUB_STEP_SUMMARY
          fi
          set -e
        continue-on-error: true
      
      - name: Ensure commit marker exists before upload
        if: always() && steps.swhid-rs-setup.outcome == 'success' && steps.swhid-rs-setup.outputs.swhid_rs_rebuilt == 'true'
        shell: bash
        run: |
          echo "=== STEP 1: Ensuring commit marker exists in target directory ==="
          cd /tmp/swhid-rs
          
          # Get commit hash
          SWHID_RS_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
          echo "Current swhid-rs commit: ${SWHID_RS_COMMIT:0:7} (full: $SWHID_RS_COMMIT)"
          
          # Ensure target directory exists
          mkdir -p target
          
          # Create/update commit marker (as hidden file)
          echo "$SWHID_RS_COMMIT" > target/.swhid-rs-commit
          
          # Also create a non-hidden version for artifact inclusion
          echo "$SWHID_RS_COMMIT" > target/swhid-rs-commit.txt
          
          # Verify both were created
          echo ""
          echo "=== Verifying commit markers ==="
          if [ -f target/.swhid-rs-commit ]; then
            echo "‚úÖ Hidden marker created: $(cat target/.swhid-rs-commit)"
            ls -la target/.swhid-rs-commit
          else
            echo "‚ùå ERROR: Failed to create hidden commit marker!"
            exit 1
          fi
          
          if [ -f target/swhid-rs-commit.txt ]; then
            echo "‚úÖ Non-hidden marker created: $(cat target/swhid-rs-commit.txt)"
            ls -la target/swhid-rs-commit.txt
          else
            echo "‚ùå ERROR: Failed to create non-hidden commit marker!"
            exit 1
          fi
          
          # List target directory to verify structure
          echo ""
          echo "=== Target directory structure (all files, including hidden) ==="
          ls -la target/ | head -20 || true
          
          # Check if release directory exists
          if [ -d target/release ]; then
            echo ""
            echo "=== Release directory structure ==="
            ls -la target/release/ | head -10 || true
            # Also copy marker to release directory
            cp target/.swhid-rs-commit target/release/.swhid-rs-commit 2>/dev/null || true
            cp target/swhid-rs-commit.txt target/release/swhid-rs-commit.txt 2>/dev/null || true
            echo "Copied markers to release directory"
          fi
          
          # Find all commit markers
          echo ""
          echo "=== Searching for all commit markers ==="
          find target -name ".swhid-rs-commit" -o -name "swhid-rs-commit.txt" 2>/dev/null | sort || true
        continue-on-error: true
      
      - name: Verify files before artifact upload
        if: always() && steps.swhid-rs-setup.outcome == 'success' && steps.swhid-rs-setup.outputs.swhid_rs_rebuilt == 'true'
        id: verify-upload
        shell: bash
        run: |
          echo "=== STEP 2: Verifying files before artifact upload ==="
          
          # Use SWHID_RS_PATH if available, otherwise default to /tmp/swhid-rs
          SWHID_RS_DIR="${SWHID_RS_PATH:-/tmp/swhid-rs}"
          echo "Using swhid-rs directory: $SWHID_RS_DIR"
          
          cd "$SWHID_RS_DIR"
          
          # Get absolute path for artifact upload
          TARGET_DIR="$(pwd)/target"
          echo "Target directory (absolute): $TARGET_DIR"
          echo "target_dir=$TARGET_DIR" >> $GITHUB_OUTPUT
          
          echo "Checking commit markers:"
          if [ -f target/.swhid-rs-commit ]; then
            echo "‚úÖ Hidden marker exists: $(cat target/.swhid-rs-commit)"
          else
            echo "‚ùå Hidden marker missing!"
          fi
          
          if [ -f target/swhid-rs-commit.txt ]; then
            echo "‚úÖ Non-hidden marker exists: $(cat target/swhid-rs-commit.txt)"
          else
            echo "‚ùå Non-hidden marker missing!"
          fi
          
          echo ""
          echo "Target directory size:"
          du -sh target/ || true
          
          echo ""
          echo "Files to be uploaded (first 20):"
          find target -type f | head -20 || true
          
          # Verify the path exists and is accessible
          if [ ! -d "target" ]; then
            echo "‚ùå ERROR: target directory does not exist at $TARGET_DIR"
            exit 1
          fi
        continue-on-error: true
      
      - name: Upload swhid-rs build artifacts (if rebuilt)
        if: always() && steps.swhid-rs-setup.outcome == 'success' && steps.swhid-rs-setup.outputs.swhid_rs_rebuilt == 'true' && steps.verify-upload.outcome == 'success'
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: swhid-rs-target-Linux
          path: ${{ steps.verify-upload.outputs.target_dir || '/tmp/swhid-rs/target' }}
          retention-days: 1
          if-no-files-found: ignore
          # Note: upload-artifact@v4 may exclude hidden files by default
          # We've created both .swhid-rs-commit (hidden) and swhid-rs-commit.txt (non-hidden)
      
      - name: Run harness unit tests
        run: |
          pytest tests/unit/ tests/integration/ -v --tb=short
      
      - name: Run full test suite (all categories and implementations)
        shell: bash
        run: |
          # Run full test suite with all available implementations
          # The harness will automatically skip implementations that are not available
          swhid-harness --output-format canonical --dashboard-output results.json || true
          echo "Full test suite completed (some implementations may be skipped)"
      
      - name: Generate HTML results table
        if: always()
        shell: bash
        run: |
          if [ -f results.json ]; then
            python scripts/view_results.py results.json --output results.html || echo "Warning: Could not generate HTML table"
            if [ -f results.html ]; then
              echo "‚úÖ HTML results table generated: results.html" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è No results.json file found, skipping HTML generation" >> $GITHUB_STEP_SUMMARY
          fi
        continue-on-error: true
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: results-ubuntu-24.04-py3.12
          path: |
            results.json
            results.html
          retention-days: 30
      
      - name: Generate test summary
        if: always()
        shell: bash
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f results.json ]; then
            # Generate statistics
            python3 -c "import json; fp=open('results.json'); d=json.load(fp); fp.close(); a=d.get('aggregates',{}); b=a.get('by_implementation',{}); p=sum(s.get('passed',0) for s in b.values()); fa=sum(s.get('failed',0) for s in b.values()); sk=sum(s.get('skipped',0) for s in b.values()); t=p+fa+sk; r=(p/t*100) if t>0 else 0; print(f'| Metric | Value |'); print(f'|--------|-------|'); print(f'| Total Tests | {t} |'); print(f'| Passed | {p} |'); print(f'| Failed | {fa} |'); print(f'| Skipped | {sk} |'); print(f'| Success Rate | {r:.1f}% |') if b else print('| Note | Results format not recognized |')" >> $GITHUB_STEP_SUMMARY 2>&1 || echo "| Note | Error parsing results |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            # Add link to HTML results if available
            if [ -f results.html ]; then
              echo "### üìä Detailed Results" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üì• Download the [HTML results table](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) from the artifacts." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "The HTML table provides a color-coded view of all test results across all implementations." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Note | No results file (harness tests may have been skipped) |" >> $GITHUB_STEP_SUMMARY
          fi


  save-cache:
    runs-on: ubuntu-24.04
    needs: test
    if: always()
    permissions:
      contents: read
    steps:
      - name: Check if artifacts were uploaded
        id: check-artifacts
        shell: bash
        run: |
          echo "Checking if swhid-rs artifacts were uploaded in test jobs..."
          # The artifact is only uploaded if swhid_rs_rebuilt == 'true'
          # We'll try to download it, but handle the case where it doesn't exist
          echo "artifact_expected=true" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: Download swhid-rs build artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: swhid-rs-target-Linux
          path: /tmp/swhid-rs-cache
      
      - name: Handle missing artifact
        if: steps.download-artifacts.outcome != 'success'
        shell: bash
        run: |
          echo "‚ö†Ô∏è Artifact 'swhid-rs-target-Linux' not found"
          echo "This is expected if:"
          echo "  - swhid-rs was not rebuilt (using cached binary)"
          echo "  - swhid-rs build failed"
          echo "  - swhid-rs setup step was skipped"
          echo ""
          echo "Skipping cache save - no new artifacts to cache."
        continue-on-error: true
      
      - name: Reorganize artifacts to match cache path structure
        if: steps.download-artifacts.outcome == 'success'
        shell: bash
        run: |
          echo "=== STEP 3: Reorganizing artifacts to match cache path structure ==="
          echo ""
          echo "Artifact was downloaded to /tmp/swhid-rs-cache"
          echo "We need to reorganize it to /tmp/swhid-rs/target to match restore path"
          echo ""
          
          # Create the target directory structure
          mkdir -p /tmp/swhid-rs
          
          # Check what structure the artifact has
          echo "Checking artifact structure:"
          ls -la /tmp/swhid-rs-cache/ || true
          
          # The artifact might be:
          # 1. /tmp/swhid-rs-cache/target/ (if directory structure preserved)
          # 2. /tmp/swhid-rs-cache/ (if flattened - contains target contents directly)
          
          if [ -d /tmp/swhid-rs-cache/target ]; then
            echo "Artifact has target/ subdirectory - moving to /tmp/swhid-rs/target"
            mv /tmp/swhid-rs-cache/target /tmp/swhid-rs/target
          elif [ -d /tmp/swhid-rs-cache/release ] || [ -f /tmp/swhid-rs-cache/.swhid-rs-commit ] || [ -f /tmp/swhid-rs-cache/swhid-rs-commit.txt ]; then
            echo "Artifact is flattened - contents are directly in /tmp/swhid-rs-cache"
            echo "Moving contents to /tmp/swhid-rs/target"
            mv /tmp/swhid-rs-cache /tmp/swhid-rs/target
          else
            echo "‚ö†Ô∏è Warning: Unexpected artifact structure"
            echo "Attempting to move /tmp/swhid-rs-cache to /tmp/swhid-rs/target"
            mv /tmp/swhid-rs-cache /tmp/swhid-rs/target || true
          fi
          
          echo ""
          echo "Verifying final structure at /tmp/swhid-rs/target:"
          ls -la /tmp/swhid-rs/target/ | head -20 || true
          
          echo ""
          echo "Searching for commit markers:"
          find /tmp/swhid-rs/target -type f \( -name ".swhid-rs-commit" -o -name "swhid-rs-commit.txt" \) 2>/dev/null | sort || echo "No commit markers found"
          
          echo ""
          echo "Finding swhid binary:"
          find /tmp/swhid-rs/target -type f -name "swhid" | head -5 || true
        continue-on-error: true
      
      - name: Verify commit marker before cache save
        if: steps.download-artifacts.outcome == 'success'
        id: get-commit-hash
        shell: bash
        run: |
          echo "=== STEP 4: Verifying commit marker before cache save ==="
          
          # Try to find the commit marker in /tmp/swhid-rs/target (reorganized location)
          COMMIT_MARKER=""
          if [ -f /tmp/swhid-rs/target/.swhid-rs-commit ]; then
            COMMIT_MARKER="/tmp/swhid-rs/target/.swhid-rs-commit"
          elif [ -f /tmp/swhid-rs/target/swhid-rs-commit.txt ]; then
            COMMIT_MARKER="/tmp/swhid-rs/target/swhid-rs-commit.txt"
          elif [ -f /tmp/swhid-rs/target/release/.swhid-rs-commit ]; then
            COMMIT_MARKER="/tmp/swhid-rs/target/release/.swhid-rs-commit"
          elif [ -f /tmp/swhid-rs/target/release/swhid-rs-commit.txt ]; then
            COMMIT_MARKER="/tmp/swhid-rs/target/release/swhid-rs-commit.txt"
          fi
          
          if [ -n "$COMMIT_MARKER" ]; then
            COMMIT_HASH=$(cat "$COMMIT_MARKER" | tr -d '[:space:]')
            echo "‚úÖ Commit marker found at: $COMMIT_MARKER"
            echo "Commit hash: $COMMIT_HASH"
            echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
            
            # Ensure it's in the expected location for cache
            if [ ! -f /tmp/swhid-rs/target/.swhid-rs-commit ]; then
              echo "Creating .swhid-rs-commit in target directory from found marker..."
              mkdir -p /tmp/swhid-rs/target
              cp "$COMMIT_MARKER" /tmp/swhid-rs/target/.swhid-rs-commit
              echo "Created: $(cat /tmp/swhid-rs/target/.swhid-rs-commit)"
            fi
          else
            echo "‚ö†Ô∏è WARNING: No commit marker found in artifact!"
            echo "This may cause cache validation issues."
            # Use a fallback: workflow run ID to make key unique
            echo "commit_hash=${{ github.run_id }}" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true
      
      - name: Save swhid-rs build cache
        if: steps.download-artifacts.outcome == 'success' && steps.get-commit-hash.outcome == 'success'
        uses: actions/cache/save@v4
        continue-on-error: true
        with:
          # CRITICAL: Use the same path as restore step to avoid cache version mismatch
          # Restore uses: /tmp/swhid-rs/target
          # Save must use: /tmp/swhid-rs/target (exact same path)
          # GitHub Actions caches are scoped by path - different paths = different cache versions
          path: /tmp/swhid-rs/target
          # Include commit hash in cache key - each commit gets its own cache
          # This allows multiple commits to have caches simultaneously
          # restore-keys with prefix matching will find the most recent cache
          # NOTE: GitHub Actions caches are IMMUTABLE - once created, they cannot be overwritten.
          # If a cache with this exact key already exists, the save will fail with "Unable to reserve cache".
          # This is expected and harmless (continue-on-error handles it) - it means we already have this cache.
          key: swhid-rs-Linux-stable-ubuntu-workflow-${{ steps.get-commit-hash.outputs.commit_hash }}
      
      - name: Debug cache save result
        if: steps.download-artifacts.outcome == 'success' && steps.get-commit-hash.outcome == 'success'
        shell: bash
        run: |
          echo "Cache save completed (check logs above for any errors)"
          echo "Cache key used: swhid-rs-Linux-stable-ubuntu-workflow-${{ steps.get-commit-hash.outputs.commit_hash }}"
          echo "Cache path: /tmp/swhid-rs/target"
          if [ -d /tmp/swhid-rs/target ]; then
            echo "‚úÖ Target directory exists and will be cached"
            du -sh /tmp/swhid-rs/target || true
          else
            echo "‚ö†Ô∏è Warning: Target directory does not exist"
          fi
        continue-on-error: true
