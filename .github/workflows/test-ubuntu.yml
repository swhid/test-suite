name: SWHID Testing Harness (Ubuntu)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04]
        python-version: ["3.10", "3.12"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for commit info
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'  # Automatically cache pip packages
          # Note: setup-python@v5 handles pip caching automatically, no need for explicit cache step
      
      - name: Install system dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y libgit2-dev pkg-config libssl-dev
        continue-on-error: true
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e .[dev] psutil
      
      - name: Install Software Heritage Python tools
        shell: bash
        run: |
          pip install swh.model swh.core || echo "Warning: swh Python tools not available, some implementations may be skipped"
        continue-on-error: true
      
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: false
        continue-on-error: true
      
      - name: Cache swhid gem
        id: cache-swhid-gem
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.gem/ruby
            ~/.local/share/gem
            ${{ runner.toolCache }}/Ruby/*/x64/lib/ruby/gems
            ${{ runner.toolCache }}/Ruby/*/x64/bin
          # Note: Cache key doesn't include version - we validate after restore
          # runner.toolCache is /opt/hostedtoolcache on Linux
          key: swhid-gem-${{ runner.os }}-ruby-3.2
          restore-keys: |
            swhid-gem-${{ runner.os }}-ruby-3.2-
      
      - name: Determine CPU cores
        id: cpu-cores
        shell: bash
        run: |
          if command -v nproc >/dev/null 2>&1; then
            CORES=$(nproc)
          elif command -v sysctl >/dev/null 2>&1; then
            CORES=$(sysctl -n hw.ncpu)
          elif command -v getconf >/dev/null 2>&1; then
            CORES=$(getconf _NPROCESSORS_ONLN)
          else
            CORES=4
          fi
          echo "cores=${CORES}" >> $GITHUB_OUTPUT
          echo "Using parallel compilation with ${CORES} cores"
      
      - name: Install swhid gem
        shell: bash
        run: |
          # Get cores from previous step (with fallback)
          CORES="${{ steps.cpu-cores.outputs.cores }}"
          if [ -z "${CORES}" ] || [ "${CORES}" = "" ]; then
            # Fallback if output not available
            if command -v nproc >/dev/null 2>&1; then
              CORES=$(nproc)
            elif command -v sysctl >/dev/null 2>&1; then
              CORES=$(sysctl -n hw.ncpu)
            else
              CORES=4
            fi
          fi
          
          # Unset any existing MAKE variable that might have wrong value
          unset MAKE || true
          
          # Set MAKE with evaluated cores value
          export MAKE="make -j${CORES}"
          echo "MAKE variable set to: ${MAKE}"
          echo "Verifying MAKE variable:"
          echo "${MAKE}" | head -1
          
          # Check if gem is already installed and validate version
          INSTALLED_VERSION=""
          GEM_AVAILABLE=false
          if gem list -i swhid >/dev/null 2>&1; then
            INSTALLED_VERSION=$(gem list swhid | grep -E "^\s*swhid\s" | sed -E 's/^\s*swhid\s+\(([^)]+)\).*/\1/' | head -1 || echo "")
            echo "swhid gem found in cache: version ${INSTALLED_VERSION}"
            
            # Verify gem is actually usable (not just listed)
            if ruby -r swhid -e "true" 2>/dev/null; then
              GEM_AVAILABLE=true
              echo "Verified: Cached gem is usable"
            else
              echo "Warning: Cached gem is listed but not usable, will reinstall"
              GEM_AVAILABLE=false
            fi
          fi
          
          # Get latest available version
          GEM_SEARCH_OUTPUT=$(gem search -r -e swhid 2>/dev/null | grep -E "^swhid\s" | head -1 || echo "")
          if [ -n "$GEM_SEARCH_OUTPUT" ]; then
            LATEST_VERSION=$(echo "$GEM_SEARCH_OUTPUT" | sed -E 's/^swhid\s+\(([^,)]+).*\)$/\1/' | xargs)
            echo "Latest available swhid gem version: ${LATEST_VERSION}"
            
            # Check if we need to reinstall
            if [ -n "$INSTALLED_VERSION" ] && [ "$INSTALLED_VERSION" = "$LATEST_VERSION" ] && [ "$GEM_AVAILABLE" = "true" ]; then
              echo "Cached gem version (${INSTALLED_VERSION}) matches latest and is usable, using cache"
              gem list swhid
            else
              if [ -n "$INSTALLED_VERSION" ]; then
                echo "Cached gem version (${INSTALLED_VERSION}) differs from latest (${LATEST_VERSION}), reinstalling..."
              else
                echo "Installing swhid gem (this may take a while for native extensions)..."
              fi
              # Uninstall old version if exists, then install latest
              gem uninstall swhid -x 2>/dev/null || true
              env MAKE="${MAKE}" gem install swhid --no-document || echo "Warning: swhid gem not available, Ruby implementation will be skipped"
            fi
          else
            # Fallback: if we can't check version, use cached gem if available and usable
            if [ -n "$INSTALLED_VERSION" ] && [ "$GEM_AVAILABLE" = "true" ]; then
              echo "Cannot check latest version, using cached gem (${INSTALLED_VERSION})"
              gem list swhid
            else
              echo "Installing swhid gem (this may take a while for native extensions)..."
              env MAKE="${MAKE}" gem install swhid --no-document || echo "Warning: swhid gem not available, Ruby implementation will be skipped"
            fi
          fi
          
          # Ensure gem bin directory is in PATH for harness to find swhid command
          # ruby/setup-ruby should do this, but let's be explicit
          set +e  # Temporarily disable exit on error for detection logic
          
          # Method 1: Use gem env to get executable directory
          # On Windows, gem env outputs paths with forward slashes, handle both formats
          GEM_BIN_DIR=$(gem env 2>/dev/null | grep -E "EXECUTABLE DIRECTORY" | sed -E 's/.*EXECUTABLE DIRECTORY[^:]*: *//' 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | head -1 || echo "")
          
          # Method 2: Try Gem.user_dir
          if [ -z "$GEM_BIN_DIR" ] || [ ! -d "$GEM_BIN_DIR" ]; then
            GEM_USER_DIR=$(ruby -e "puts Gem.user_dir" 2>/dev/null || echo "")
            if [ -n "$GEM_USER_DIR" ] && [ "$GEM_USER_DIR" != "" ]; then
              GEM_BIN_DIR="$GEM_USER_DIR/bin"
            fi
          fi
          
          # Method 3: Search for swhid executable and use its directory
          if [ -z "$GEM_BIN_DIR" ] || [ ! -d "$GEM_BIN_DIR" ] || [ ! -f "$GEM_BIN_DIR/swhid" ]; then
            # Search in common gem installation locations
            # Use runner.toolCache which works on all platforms
            TOOL_CACHE="${RUNNER_TOOL_CACHE:-/opt/hostedtoolcache}"
            SWHID_PATH=$(find ~/.local/share/gem ~/.gem "$TOOL_CACHE/Ruby" -name swhid -type f 2>/dev/null | head -1 || echo "")
            if [ -n "$SWHID_PATH" ] && [ "$SWHID_PATH" != "" ]; then
              GEM_BIN_DIR=$(dirname "$SWHID_PATH")
              echo "Found swhid at: $SWHID_PATH"
            fi
          fi
          
          # Method 4: Try common locations
          if [ -z "$GEM_BIN_DIR" ] || [ ! -d "$GEM_BIN_DIR" ]; then
            TOOL_CACHE="${RUNNER_TOOL_CACHE:-/opt/hostedtoolcache}"
            for dir in ~/.local/share/gem/ruby/*/bin ~/.gem/ruby/*/bin "$TOOL_CACHE/Ruby"/*/x64/lib/ruby/gems/*/bin "$TOOL_CACHE/Ruby"/*/x64/bin; do
              if [ -d "$dir" ] && [ -f "$dir/swhid" ] 2>/dev/null; then
                GEM_BIN_DIR="$dir"
                echo "Found swhid in: $dir"
                break
              fi
            done
          fi
          
          set -e  # Re-enable exit on error
          
          # Add to PATH if found
          if [ -n "$GEM_BIN_DIR" ] && [ "$GEM_BIN_DIR" != "" ] && [ -d "$GEM_BIN_DIR" ]; then
            # Add to GITHUB_PATH (affects subsequent steps)
            echo "$GEM_BIN_DIR" >> $GITHUB_PATH
            # Also add to current PATH for this step
            export PATH="$GEM_BIN_DIR:$PATH"
            echo "‚úÖ Added gem bin directory to PATH: $GEM_BIN_DIR"
          else
            echo "‚ö†Ô∏è Warning: Could not determine gem bin directory"
            echo "Gem environment:"
            gem env 2>/dev/null | grep -E "(EXECUTABLE|INSTALLATION)" || true
          fi
          
          # Verify swhid command is accessible
          if command -v swhid >/dev/null 2>&1; then
            echo "‚úÖ swhid command found in PATH: $(which swhid)"
          else
            echo "‚ö†Ô∏è Warning: swhid command not found in PATH, but gem is installed"
            echo "Gem bin directory: $GEM_BIN_DIR"
            echo "Searching for swhid command..."
            find ~/.local/share/gem ~/.gem /opt/hostedtoolcache/Ruby -name swhid -type f 2>/dev/null | head -5 || echo "Not found in common locations"
            echo "Current PATH: $PATH"
          fi
        continue-on-error: true
      
      - name: Configure Git for SWHID testing
        shell: bash
        run: |
          # Configure Git to preserve line endings and file permissions for SWHID testing
          git config --global core.autocrlf false
          git config --global core.filemode true
          git config --global core.precomposeunicode false
          git config --global core.quotepath false
          echo "Git configured for SWHID testing"
      
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
        continue-on-error: true
      
      - name: Cache Cargo registry and git cache
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          # Note: Cargo.lock is in swhid-rs repo (cloned later), so we use a simple key
          # The cache is for downloaded crates, which are versioned by Cargo itself
          # Cargo will re-download if versions don't match, so this cache is safe
          key: cargo-${{ runner.os }}-registry
          restore-keys: |
            cargo-${{ runner.os }}-
      
      - name: Cache swhid-rs build artifacts
        id: cache-swhid-rs
        uses: actions/cache/restore@v4
        continue-on-error: true
        with:
          # Use /tmp/swhid-rs/target - works on all platforms with bash shell
          # Try workflow-specific cache first, then fall back to generic cache
          # This allows both workflows to share caches while avoiding save conflicts
          path: /tmp/swhid-rs/target
          key: swhid-rs-Linux-stable-ubuntu-workflow
          restore-keys: |
            swhid-rs-Linux-stable-ubuntu-workflow
            swhid-rs-Linux-stable-multi-platform-workflow
            swhid-rs-Linux-stable
            swhid-rs-Linux-
      
      - name: Check cache restore status
        shell: bash
        run: |
          if [ -d /tmp/swhid-rs/target/release ] && [ -f /tmp/swhid-rs/target/release/swhid ]; then
            CACHED_COMMIT_FILE="/tmp/swhid-rs/target/.swhid-rs-commit"
            if [ -f "$CACHED_COMMIT_FILE" ]; then
              CACHED_COMMIT=$(cat "$CACHED_COMMIT_FILE" 2>/dev/null || echo "unknown")
              echo "‚úÖ Cache hit: Found cached binary for commit ${CACHED_COMMIT:0:7}"
              echo "Cached commit: $CACHED_COMMIT"
            else
              echo "‚ö†Ô∏è Cache hit: Found cached binary but no commit marker (will need validation)"
            fi
          else
            echo "‚ùå Cache miss: No cached binary found"
          fi
        continue-on-error: true
      
      - name: Setup SSH for private repository access (optional)
        shell: bash
        run: |
          mkdir -p ~/.ssh
          if [ -n "${{ secrets.SWHID_RS_SSH_KEY }}" ]; then
            echo "${{ secrets.SWHID_RS_SSH_KEY }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null
            echo "SSH key configured for repository access"
          else
            echo "No SSH key provided - using public HTTPS access"
          fi
        continue-on-error: true
      
      - name: Clone and build swhid-rs
        id: swhid-rs-setup
        shell: bash
        env:
          SWHID_RS_REPO: ${{ secrets.SWHID_RS_REPO || 'https://github.com/swhid/swhid-rs.git' }}
          SWHID_RS_TOKEN: ${{ secrets.SWHID_RS_TOKEN }}
        run: |
          set +e
          # Preserve cached target/ directory if it exists
          if [ -d /tmp/swhid-rs/target ]; then
            echo "Preserving cached build artifacts..."
            mkdir -p /tmp/swhid-rs-cache-backup
            mv /tmp/swhid-rs/target /tmp/swhid-rs-cache-backup/ || true
          fi
          
          # Clean up any existing /tmp/swhid-rs directory
          if [ -d /tmp/swhid-rs ]; then
            echo "Cleaning up existing /tmp/swhid-rs directory..."
            rm -rf /tmp/swhid-rs
          fi
          
          # Try to clone the swhid-rs repository
          if [ -n "$SWHID_RS_REPO" ]; then
            echo "Attempting to clone swhid-rs from $SWHID_RS_REPO"
            # Use HTTPS with token if available (for private repos, or public access if no token)
            if [[ "$SWHID_RS_REPO" == https://* ]]; then
              # Force HTTPS by disabling SSH and avoiding system Git configs
              echo "=== Debug: Git configuration before clone ==="
              echo "Git version: $(git --version)"
              echo "GIT_SSH_COMMAND: ${GIT_SSH_COMMAND:-<unset>}"
              echo "GIT_CONFIG_NOSYSTEM: ${GIT_CONFIG_NOSYSTEM:-<unset>}"
              echo "SSH key exists: $([ -f ~/.ssh/id_rsa ] && echo 'yes' || echo 'no')"
              git config --global --list 2>/dev/null | grep -E "(url|ssh)" || echo "No global URL/SSH configs"
              git config --system --list 2>/dev/null | grep -E "(url|ssh)" || echo "No system URL/SSH configs"
              echo "Testing URL parsing..."
              echo "Original URL: $SWHID_RS_REPO"
              echo "=== End debug ==="
              
              # Completely disable SSH for this operation
              unset GIT_SSH_COMMAND
              unset GIT_SSH
              export GIT_CONFIG_NOSYSTEM=1
              export GIT_SSH_VARIANT=simple
              export GIT_TERMINAL_PROMPT=0
              
              if [ -n "$SWHID_RS_TOKEN" ]; then
                # Use dedicated token for repository access (if needed for private repos)
                # Construct URL properly: extract domain and path, then rebuild with token
                REPO_URL="https://${SWHID_RS_TOKEN}@${SWHID_RS_REPO#https://}"
                echo "Using token for repository access"
                echo "Repository URL (masked): https://***@${SWHID_RS_REPO#https://}"
                echo "Attempting clone with explicit HTTPS..."
                # Unset GIT_SSH_COMMAND (don't set to empty string) and force HTTPS
                (unset GIT_SSH_COMMAND; unset GIT_SSH; GIT_CONFIG_NOSYSTEM=1 git clone "$REPO_URL" /tmp/swhid-rs 2>&1) | tee /tmp/swhid-rs-clone.log
                CLONE_EXIT_CODE=${PIPESTATUS[0]}
              elif [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
                # Fallback to GITHUB_TOKEN if available (for private repos)
                GITHUB_TOKEN_VALUE="${{ secrets.GITHUB_TOKEN }}"
                REPO_URL="https://${GITHUB_TOKEN_VALUE}@${SWHID_RS_REPO#https://}"
                echo "Using GITHUB_TOKEN for repository access"
                echo "Repository URL (masked): https://***@${SWHID_RS_REPO#https://}"
                echo "Attempting clone with explicit HTTPS..."
                (unset GIT_SSH_COMMAND; unset GIT_SSH; GIT_CONFIG_NOSYSTEM=1 git clone "$REPO_URL" /tmp/swhid-rs 2>&1) | tee /tmp/swhid-rs-clone.log
                CLONE_EXIT_CODE=${PIPESTATUS[0]}
              else
                # Use public access (works for public repositories)
                echo "No token available, using public HTTPS access"
                echo "Attempting clone with explicit HTTPS..."
                (unset GIT_SSH_COMMAND; unset GIT_SSH; GIT_CONFIG_NOSYSTEM=1 git clone "$SWHID_RS_REPO" /tmp/swhid-rs 2>&1) | tee /tmp/swhid-rs-clone.log
                CLONE_EXIT_CODE=${PIPESTATUS[0]}
              fi
            else
              # SSH URL - use SSH key if configured
              git clone "$SWHID_RS_REPO" /tmp/swhid-rs 2>&1 | tee /tmp/swhid-rs-clone.log
              CLONE_EXIT_CODE=${PIPESTATUS[0]}
            fi
            if [ $CLONE_EXIT_CODE -eq 0 ] && [ -d /tmp/swhid-rs ]; then
              cd /tmp/swhid-rs
              
              # Get the current commit hash of swhid-rs to check if we need to rebuild
              SWHID_RS_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
              echo "swhid-rs commit: ${SWHID_RS_COMMIT:0:7}"
              
              # Restore cached target/ directory if it was preserved
              if [ -d /tmp/swhid-rs-cache-backup/target ]; then
                echo "Restoring cached build artifacts..."
                mv /tmp/swhid-rs-cache-backup/target . || true
                rm -rf /tmp/swhid-rs-cache-backup || true
              fi
              
              # Check if we have cached build artifacts and if they match current source
              # We check for the binary AND verify it was built from the same commit
              CACHED_COMMIT_FILE="target/.swhid-rs-commit"
              NEED_REBUILD=true
              REBUILT=false
              
              if [ -d target/release ] && [ -f target/release/swhid ]; then
                if [ -f "$CACHED_COMMIT_FILE" ]; then
                  CACHED_COMMIT=$(cat "$CACHED_COMMIT_FILE" 2>/dev/null || echo "")
                  if [ "$CACHED_COMMIT" = "$SWHID_RS_COMMIT" ]; then
                    echo "‚úÖ Using cached swhid-rs binary (commit ${SWHID_RS_COMMIT:0:7})"
                    echo "Cache validation: Commit hash matches, no rebuild needed"
                    BUILD_EXIT_CODE=0
                    NEED_REBUILD=false
                  else
                    echo "üîÑ Changes detected: Cached commit ${CACHED_COMMIT:0:7} != current commit ${SWHID_RS_COMMIT:0:7}"
                    echo "Cached commit: ${CACHED_COMMIT:0:7}"
                    echo "Current commit: ${SWHID_RS_COMMIT:0:7}"
                    echo "Rebuilding swhid-rs to match current commit..."
                  fi
                else
                  echo "‚ö†Ô∏è Cached binary exists but no commit marker found, rebuilding to be safe..."
                fi
              else
                echo "‚ùå No cached binary found, building swhid-rs..."
              fi
              
              if [ "$NEED_REBUILD" = "true" ]; then
                cargo build --release --features git 2>&1 | tee /tmp/swhid-rs-build.log
                BUILD_EXIT_CODE=${PIPESTATUS[0]}
                if [ $BUILD_EXIT_CODE -eq 0 ]; then
                  REBUILT=true
                  # Save the commit hash for future cache validation
                  # Ensure target directory exists and write commit marker
                  mkdir -p target
                  echo "$SWHID_RS_COMMIT" > "$CACHED_COMMIT_FILE"
                  echo "Build completed successfully, saved commit marker to $CACHED_COMMIT_FILE"
                  # Verify the file was written
                  if [ -f "$CACHED_COMMIT_FILE" ]; then
                    echo "Commit marker verified: $(cat "$CACHED_COMMIT_FILE")"
                  else
                    echo "WARNING: Commit marker file was not created!"
                  fi
                fi
              fi
              
              # Set output to indicate if we rebuilt (needed for cache save step)
              echo "swhid_rs_rebuilt=${REBUILT}" >> $GITHUB_OUTPUT
              if [ $BUILD_EXIT_CODE -eq 0 ]; then
                echo "swhid-rs built successfully"
                echo "SWHID_RS_PATH=/tmp/swhid-rs" >> $GITHUB_ENV
                echo "swhid_rs_available=true" >> $GITHUB_ENV
                echo "‚úÖ swhid-rs is available" >> $GITHUB_STEP_SUMMARY
              else
                echo "swhid-rs build failed (exit code: $BUILD_EXIT_CODE)"
                echo "Last 20 lines of build log:"
                tail -20 /tmp/swhid-rs-build.log || true
                echo "swhid_rs_available=false" >> $GITHUB_ENV
                echo "‚ö†Ô∏è swhid-rs build failed" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "swhid-rs repository clone failed (exit code: $CLONE_EXIT_CODE)"
              if [ -f /tmp/swhid-rs-clone.log ]; then
                echo "Clone log:"
                cat /tmp/swhid-rs-clone.log
              fi
              if [ ! -d /tmp/swhid-rs ]; then
                echo "Directory /tmp/swhid-rs does not exist"
              fi
              echo "swhid_rs_available=false" >> $GITHUB_ENV
              echo "‚ÑπÔ∏è swhid-rs repository not accessible - Rust implementation will be skipped" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "SWHID_RS_REPO not configured"
            echo "swhid_rs_available=false" >> $GITHUB_ENV
            echo "‚ÑπÔ∏è SWHID_RS_REPO not configured - Rust implementation will be skipped" >> $GITHUB_STEP_SUMMARY
          fi
          set -e
        continue-on-error: true
      
      - name: Ensure commit marker exists before upload
        if: always() && steps.swhid-rs-setup.outcome == 'success' && steps.swhid-rs-setup.outputs.swhid_rs_rebuilt == 'true'
        shell: bash
        run: |
          echo "=== STEP 1: Ensuring commit marker exists in target directory ==="
          cd /tmp/swhid-rs
          
          # Get commit hash
          SWHID_RS_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
          echo "Current swhid-rs commit: ${SWHID_RS_COMMIT:0:7} (full: $SWHID_RS_COMMIT)"
          
          # Ensure target directory exists
          mkdir -p target
          
          # Create/update commit marker (as hidden file)
          echo "$SWHID_RS_COMMIT" > target/.swhid-rs-commit
          
          # Also create a non-hidden version for artifact inclusion
          echo "$SWHID_RS_COMMIT" > target/swhid-rs-commit.txt
          
          # Verify both were created
          echo ""
          echo "=== Verifying commit markers ==="
          if [ -f target/.swhid-rs-commit ]; then
            echo "‚úÖ Hidden marker created: $(cat target/.swhid-rs-commit)"
            ls -la target/.swhid-rs-commit
          else
            echo "‚ùå ERROR: Failed to create hidden commit marker!"
            exit 1
          fi
          
          if [ -f target/swhid-rs-commit.txt ]; then
            echo "‚úÖ Non-hidden marker created: $(cat target/swhid-rs-commit.txt)"
            ls -la target/swhid-rs-commit.txt
          else
            echo "‚ùå ERROR: Failed to create non-hidden commit marker!"
            exit 1
          fi
          
          # List target directory to verify structure
          echo ""
          echo "=== Target directory structure (all files, including hidden) ==="
          ls -la target/ | head -20 || true
          
          # Check if release directory exists
          if [ -d target/release ]; then
            echo ""
            echo "=== Release directory structure ==="
            ls -la target/release/ | head -10 || true
            # Also copy marker to release directory
            cp target/.swhid-rs-commit target/release/.swhid-rs-commit 2>/dev/null || true
            cp target/swhid-rs-commit.txt target/release/swhid-rs-commit.txt 2>/dev/null || true
            echo "Copied markers to release directory"
          fi
          
          # Find all commit markers
          echo ""
          echo "=== Searching for all commit markers ==="
          find target -name ".swhid-rs-commit" -o -name "swhid-rs-commit.txt" 2>/dev/null | sort || true
        continue-on-error: true
      
      - name: Verify files before artifact upload
        if: always() && steps.swhid-rs-setup.outcome == 'success' && steps.swhid-rs-setup.outputs.swhid_rs_rebuilt == 'true'
        id: verify-upload
        shell: bash
        run: |
          echo "=== STEP 2: Verifying files before artifact upload ==="
          
          # Use SWHID_RS_PATH if available, otherwise default to /tmp/swhid-rs
          SWHID_RS_DIR="${SWHID_RS_PATH:-/tmp/swhid-rs}"
          echo "Using swhid-rs directory: $SWHID_RS_DIR"
          
          cd "$SWHID_RS_DIR"
          
          # Get absolute path for artifact upload
          TARGET_DIR="$(pwd)/target"
          echo "Target directory (absolute): $TARGET_DIR"
          echo "target_dir=$TARGET_DIR" >> $GITHUB_OUTPUT
          
          echo "Checking commit markers:"
          if [ -f target/.swhid-rs-commit ]; then
            echo "‚úÖ Hidden marker exists: $(cat target/.swhid-rs-commit)"
          else
            echo "‚ùå Hidden marker missing!"
          fi
          
          if [ -f target/swhid-rs-commit.txt ]; then
            echo "‚úÖ Non-hidden marker exists: $(cat target/swhid-rs-commit.txt)"
          else
            echo "‚ùå Non-hidden marker missing!"
          fi
          
          echo ""
          echo "Target directory size:"
          du -sh target/ || true
          
          echo ""
          echo "Files to be uploaded (first 20):"
          find target -type f | head -20 || true
          
          # Verify the path exists and is accessible
          if [ ! -d "target" ]; then
            echo "‚ùå ERROR: target directory does not exist at $TARGET_DIR"
            exit 1
          fi
        continue-on-error: true
      
      - name: Upload swhid-rs build artifacts (if rebuilt)
        if: always() && steps.swhid-rs-setup.outcome == 'success' && steps.swhid-rs-setup.outputs.swhid_rs_rebuilt == 'true' && steps.verify-upload.outcome == 'success'
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: swhid-rs-target-Linux
          path: ${{ steps.verify-upload.outputs.target_dir || '/tmp/swhid-rs/target' }}
          retention-days: 1
          if-no-files-found: ignore
          # Note: upload-artifact@v4 may exclude hidden files by default
          # We've created both .swhid-rs-commit (hidden) and swhid-rs-commit.txt (non-hidden)
      
      - name: Run harness unit tests
        run: |
          pytest tests/unit/ tests/integration/ -v --tb=short
      
      - name: Run full test suite (all categories and implementations)
        shell: bash
        run: |
          # Run full test suite with all available implementations
          # The harness will automatically skip implementations that are not available
          swhid-harness --output-format canonical --dashboard-output results.json || true
          echo "Full test suite completed (some implementations may be skipped)"
      
      - name: Generate HTML results table
        if: always()
        shell: bash
        run: |
          if [ -f results.json ]; then
            python scripts/view_results.py results.json --output results.html || echo "Warning: Could not generate HTML table"
            if [ -f results.html ]; then
              echo "‚úÖ HTML results table generated: results.html" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è No results.json file found, skipping HTML generation" >> $GITHUB_STEP_SUMMARY
          fi
        continue-on-error: true
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: results-${{ matrix.os }}-py${{ matrix.python-version }}
          path: |
            results.json
            results.html
          retention-days: 30
      
      - name: Generate test summary
        if: always()
        shell: bash
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f results.json ]; then
            # Generate statistics
            python3 -c "import json; fp=open('results.json'); d=json.load(fp); fp.close(); a=d.get('aggregates',{}); b=a.get('by_implementation',{}); p=sum(s.get('passed',0) for s in b.values()); fa=sum(s.get('failed',0) for s in b.values()); sk=sum(s.get('skipped',0) for s in b.values()); t=p+fa+sk; r=(p/t*100) if t>0 else 0; print(f'| Metric | Value |'); print(f'|--------|-------|'); print(f'| Total Tests | {t} |'); print(f'| Passed | {p} |'); print(f'| Failed | {fa} |'); print(f'| Skipped | {sk} |'); print(f'| Success Rate | {r:.1f}% |') if b else print('| Note | Results format not recognized |')" >> $GITHUB_STEP_SUMMARY 2>&1 || echo "| Note | Error parsing results |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            # Add link to HTML results if available
            if [ -f results.html ]; then
              echo "### üìä Detailed Results" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üì• Download the [HTML results table](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) from the artifacts." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "The HTML table provides a color-coded view of all test results across all implementations." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Note | No results file (harness tests may have been skipped) |" >> $GITHUB_STEP_SUMMARY
          fi


  save-cache:
    runs-on: ubuntu-24.04
    needs: test
    if: always()
    permissions:
      contents: read
    steps:
      - name: Check if artifacts were uploaded
        id: check-artifacts
        shell: bash
        run: |
          echo "Checking if swhid-rs artifacts were uploaded in test jobs..."
          # The artifact is only uploaded if swhid_rs_rebuilt == 'true'
          # We'll try to download it, but handle the case where it doesn't exist
          echo "artifact_expected=true" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: Download swhid-rs build artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: swhid-rs-target-Linux
          path: /tmp/swhid-rs-cache
      
      - name: Handle missing artifact
        if: steps.download-artifacts.outcome != 'success'
        shell: bash
        run: |
          echo "‚ö†Ô∏è Artifact 'swhid-rs-target-Linux' not found"
          echo "This is expected if:"
          echo "  - swhid-rs was not rebuilt (using cached binary)"
          echo "  - swhid-rs build failed"
          echo "  - swhid-rs setup step was skipped"
          echo ""
          echo "Skipping cache save - no new artifacts to cache."
        continue-on-error: true
      
      - name: Check artifact structure
        if: steps.download-artifacts.outcome == 'success'
        shell: bash
        run: |
          echo "=== STEP 3: Checking artifact structure after download ==="
          echo ""
          echo "Root directory contents:"
          ls -la /tmp/swhid-rs-cache/ || true
          
          echo ""
          echo "Searching for commit markers (hidden and non-hidden):"
          find /tmp/swhid-rs-cache -type f \( -name ".swhid-rs-commit" -o -name "swhid-rs-commit.txt" \) 2>/dev/null | sort || echo "No commit markers found"
          
          echo ""
          echo "Checking if markers exist at expected locations:"
          if [ -f /tmp/swhid-rs-cache/.swhid-rs-commit ]; then
            echo "‚úÖ Found: /tmp/swhid-rs-cache/.swhid-rs-commit ($(cat /tmp/swhid-rs-cache/.swhid-rs-commit))"
          else
            echo "‚ùå Missing: /tmp/swhid-rs-cache/.swhid-rs-commit"
          fi
          
          if [ -f /tmp/swhid-rs-cache/swhid-rs-commit.txt ]; then
            echo "‚úÖ Found: /tmp/swhid-rs-cache/swhid-rs-commit.txt ($(cat /tmp/swhid-rs-cache/swhid-rs-commit.txt))"
          else
            echo "‚ùå Missing: /tmp/swhid-rs-cache/swhid-rs-commit.txt"
          fi
          
          if [ -f /tmp/swhid-rs-cache/target/.swhid-rs-commit ]; then
            echo "‚úÖ Found: /tmp/swhid-rs-cache/target/.swhid-rs-commit ($(cat /tmp/swhid-rs-cache/target/.swhid-rs-commit))"
          else
            echo "‚ùå Missing: /tmp/swhid-rs-cache/target/.swhid-rs-commit"
          fi
          
          if [ -f /tmp/swhid-rs-cache/target/swhid-rs-commit.txt ]; then
            echo "‚úÖ Found: /tmp/swhid-rs-cache/target/swhid-rs-commit.txt ($(cat /tmp/swhid-rs-cache/target/swhid-rs-commit.txt))"
          else
            echo "‚ùå Missing: /tmp/swhid-rs-cache/target/swhid-rs-commit.txt"
          fi
          
          if [ -d /tmp/swhid-rs-cache/release ]; then
            echo ""
            echo "Release directory exists, checking for markers:"
            if [ -f /tmp/swhid-rs-cache/release/.swhid-rs-commit ]; then
              echo "‚úÖ Found: /tmp/swhid-rs-cache/release/.swhid-rs-commit ($(cat /tmp/swhid-rs-cache/release/.swhid-rs-commit))"
            else
              echo "‚ùå Missing: /tmp/swhid-rs-cache/release/.swhid-rs-commit"
            fi
            
            if [ -f /tmp/swhid-rs-cache/release/swhid-rs-commit.txt ]; then
              echo "‚úÖ Found: /tmp/swhid-rs-cache/release/swhid-rs-commit.txt ($(cat /tmp/swhid-rs-cache/release/swhid-rs-commit.txt))"
            else
              echo "‚ùå Missing: /tmp/swhid-rs-cache/release/swhid-rs-commit.txt"
            fi
          fi
          
          echo ""
          echo "Finding swhid binary:"
          find /tmp/swhid-rs-cache -type f -name "swhid" | head -5 || true
        continue-on-error: true
      
      - name: Verify commit marker before cache save
        if: steps.download-artifacts.outcome == 'success'
        shell: bash
        run: |
          echo "=== STEP 4: Verifying commit marker before cache save ==="
          
          # Try to find the commit marker
          COMMIT_MARKER=""
          if [ -f /tmp/swhid-rs-cache/target/.swhid-rs-commit ]; then
            COMMIT_MARKER="/tmp/swhid-rs-cache/target/.swhid-rs-commit"
          elif [ -f /tmp/swhid-rs-cache/target/swhid-rs-commit.txt ]; then
            COMMIT_MARKER="/tmp/swhid-rs-cache/target/swhid-rs-commit.txt"
          elif [ -f /tmp/swhid-rs-cache/.swhid-rs-commit ]; then
            COMMIT_MARKER="/tmp/swhid-rs-cache/.swhid-rs-commit"
          elif [ -f /tmp/swhid-rs-cache/swhid-rs-commit.txt ]; then
            COMMIT_MARKER="/tmp/swhid-rs-cache/swhid-rs-commit.txt"
          elif [ -f /tmp/swhid-rs-cache/release/.swhid-rs-commit ]; then
            COMMIT_MARKER="/tmp/swhid-rs-cache/release/.swhid-rs-commit"
          elif [ -f /tmp/swhid-rs-cache/release/swhid-rs-commit.txt ]; then
            COMMIT_MARKER="/tmp/swhid-rs-cache/release/swhid-rs-commit.txt"
          fi
          
          if [ -n "$COMMIT_MARKER" ]; then
            echo "‚úÖ Commit marker found at: $COMMIT_MARKER"
            echo "Commit hash: $(cat "$COMMIT_MARKER")"
            
            # Ensure it's in the expected location for cache
            if [ ! -f /tmp/swhid-rs-cache/target/.swhid-rs-commit ]; then
              echo "Creating .swhid-rs-commit in target directory from found marker..."
              mkdir -p /tmp/swhid-rs-cache/target
              cp "$COMMIT_MARKER" /tmp/swhid-rs-cache/target/.swhid-rs-commit
              echo "Created: $(cat /tmp/swhid-rs-cache/target/.swhid-rs-commit)"
            fi
          else
            echo "‚ö†Ô∏è WARNING: No commit marker found in artifact!"
            echo "This may cause cache validation issues."
          fi
        continue-on-error: true
      
      - name: Save swhid-rs build cache
        if: steps.download-artifacts.outcome == 'success'
        uses: actions/cache/save@v4
        continue-on-error: true
        with:
          # The artifact contains /tmp/swhid-rs/target, so when downloaded it may be at
          # /tmp/swhid-rs-cache/target or /tmp/swhid-rs-cache depending on artifact structure
          # Try both paths - cache action will use whichever exists
          path: |
            /tmp/swhid-rs-cache/target
            /tmp/swhid-rs-cache
          # Use workflow-specific cache key to avoid conflicts when multiple workflows run simultaneously
          # Both workflows can save their own cache, and both can restore from either cache
          # This eliminates race conditions across workflows
          key: swhid-rs-Linux-stable-ubuntu-workflow
